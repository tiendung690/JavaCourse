package hr.fer.zemris.java.tecaj.hw5.db.lexer;

/**
 * A lexer that can generate tokens for the query selections used in the
 * {@code StudentDatabase}. <br>
 * The lexer has two states in which it can work. The default one is the
 * {@code LexerState#NORMAL} in which the lexer can generate symbols, operators,
 * commands and EOF tokens. The other one is {@code LexerState#STRING} in which
 * the lexer can only generate string literals and symbols.
 * 
 * @author Kristijan Vulinovic
 * @version 1.0
 */
public class Lexer {
	/** The data that this lexer uses to generate tokens. */
	private final char[] data;
	/** The working state of the lexer. */
	private LexerState state;
	/** The last generated token. */
	private Token token;
	/** The current index in the data array. */
	private int currentIndex;

	/**
	 * The supported operators that this lexer can generate as operator tokens.
	 */
	private final String[] supportedOperators = { ">=", "<=", "=", "<", ">", "!=", "LIKE" };

	/**
	 * Creates a new lexer with the given data. The default state of the lexer
	 * is {@code LexerState#NORMAL}.
	 * 
	 * @param stringData
	 *            the data for the lexer.
	 */
	public Lexer(String stringData) {
		if (stringData == null) {
			throw new LexerException("The given data is null!");
		}
		data = stringData.toCharArray();
		state = LexerState.NORMAL;
	}

	/**
	 * Sets the state of the {@code Lexer} to the new one given in the argument.
	 * 
	 * @param state
	 *            the new state for this {@code Lexer}.
	 * @throws LexerException
	 *             if the new state is null
	 */
	public void setState(LexerState state) {
		if (state == null) {
			throw new LexerException("The given state was null!");
		}
		this.state = state;
	}

	/**
	 * Returns the last token generated by the {@code Lexer}.
	 * 
	 * @return the last token generated by the {@code Lexer}.
	 */
	public Token getToken() {
		return token;
	}

	/**
	 * Generates and returns the next token calculated by the rules for this
	 * {@link Lexer}.
	 * 
	 * @return the next token calculated by this lexer.
	 */
	public Token nextToken() {
		skipBlankSpaces();
		switch (state) {
			case NORMAL:
				nextTokenNormal();
				break;
			case STRING:
				nextTokenString();
				break;
			default:
				throw new LexerException("Lexer state not supported!");
		}

		return token;
	}

	/**
	 * Goes through all the white spaces that are currently in the data, leaving
	 * the currentIndex on the first character that is not a white space.
	 */
	private void skipBlankSpaces() {
		while (currentIndex < data.length && Character.isWhitespace(data[currentIndex])) {
			currentIndex++;
		}
	}

	/**
	 * Calculates the next token when the lexer works in the state
	 * {@code LexerState#NORMAL}.
	 */
	private void nextTokenNormal() {
		if (currentIndex == data.length) {
			token = new Token(null, TokenType.EOF);
			return;
		}

		if (data[currentIndex] == '"') {
			currentIndex++;
			token = new Token('"', TokenType.SYMBOL);
			return;
		}

		if (isOperator()) {
			nextTokenOperator();
			return;
		}

		nextTokenCommand();
	}

	/**
	 * Generates the next {@code Token}, assuming that the next token is a
	 * command.
	 */
	private void nextTokenCommand() {
		StringBuilder string = new StringBuilder();

		while (currentIndex < data.length) {
			if (Character.isWhitespace(data[currentIndex])) break;
			if (isOperator()) break;
			if (data[currentIndex] == '"') break;

			string.append(data[currentIndex]);
			currentIndex++;
		}

		token = new Token(string.toString(), TokenType.COMMAND);
	}

	/**
	 * Checks if the current position in the data array is the beginning of an
	 * operator.
	 * 
	 * @return a boolean value: <strong>true</strong> if the current position is
	 *         the beginning of an operator, <strong>false</strong> otherwise.
	 */
	private boolean isOperator() {
		for (String operator : supportedOperators) {
			int opLength = operator.length();
			if (currentIndex + opLength >= data.length) {
				continue;
			}

			boolean isOperator = true;
			for (int i = 0; i < opLength; ++i) {
				if (operator.charAt(i) != data[currentIndex + i]) {
					isOperator = false;
					break;
				}
			}

			if (!isOperator) continue;
			return true;
		}
		return false;
	}

	/**
	 * Generates the next {@code Token}, assuming that the next token is an
	 * comparison operator.
	 */
	private void nextTokenOperator() {
		for (String operator : supportedOperators) {
			int opLength = operator.length();
			if (currentIndex + opLength >= data.length) {
				continue;
			}

			boolean isOperator = true;
			for (int i = 0; i < opLength; ++i) {
				if (operator.charAt(i) != data[currentIndex + i]) {
					isOperator = false;
					break;
				}
			}
			if (!isOperator) continue;

			currentIndex += opLength;
			token = new Token(operator, TokenType.OPERATOR);
			return;
		}
		throw new LexerException("There was an error while processing the current operator!");
	}

	/**
	 * Generates the next {@code Token} when the {@code Lexer} is in STRING
	 * state.
	 */
	private void nextTokenString() {
		if (data[currentIndex] == '"') {
			currentIndex++;
			token = new Token('"', TokenType.SYMBOL);
			return;
		}

		StringBuilder string = new StringBuilder();

		while (currentIndex < data.length && data[currentIndex] != '"') {
			string.append(data[currentIndex]);
			currentIndex++;
		}

		if (data[currentIndex] != '"') {
			throw new LexerException(
				"The given data contains a string literal that is not valid!");
		}

		token = new Token(string.toString(), TokenType.STRING_LITERAL);
	}
}
