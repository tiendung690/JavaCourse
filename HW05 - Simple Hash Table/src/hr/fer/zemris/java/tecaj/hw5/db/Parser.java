package hr.fer.zemris.java.tecaj.hw5.db;

import hr.fer.zemris.java.tecaj.hw5.db.comparison.EqualsCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.GreaterOrEqualThanCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.GreaterThanCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.IComparisonOperator;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.LessOrEqualThanCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.LessThanCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.NotEqualCondition;
import hr.fer.zemris.java.tecaj.hw5.db.comparison.WildCardEqualsCondition;
import hr.fer.zemris.java.tecaj.hw5.db.conditionalExpressions.CompositeExpression;
import hr.fer.zemris.java.tecaj.hw5.db.conditionalExpressions.ConditionalExpression;
import hr.fer.zemris.java.tecaj.hw5.db.conditionalExpressions.IConditionalExpression;
import hr.fer.zemris.java.tecaj.hw5.db.lexer.Lexer;
import hr.fer.zemris.java.tecaj.hw5.db.lexer.LexerException;
import hr.fer.zemris.java.tecaj.hw5.db.lexer.LexerState;
import hr.fer.zemris.java.tecaj.hw5.db.lexer.Token;
import hr.fer.zemris.java.tecaj.hw5.db.lexer.TokenType;
import hr.fer.zemris.java.tecaj.hw5.db.valueGetters.FirstNameFieldGetter;
import hr.fer.zemris.java.tecaj.hw5.db.valueGetters.IFieldValueGetter;
import hr.fer.zemris.java.tecaj.hw5.db.valueGetters.JmbagFieldGetter;
import hr.fer.zemris.java.tecaj.hw5.db.valueGetters.LastNameFieldGetter;

/**
 * Parses the given text into a {@code IConditionalExpression} that can be used.
 * Supported operations are only queries, that are able to set filters for the
 * firstName, lastName or jmbag. It is allowed to use 7 different operators:
 * &lt;, &le;, &gt;, &ge;, =, != and LIKE. It is allowed to join multiple
 * filters into one by using the AND keyword.
 * 
 * @author Kristijan Vulinovic
 * @version 1.0
 */
public class Parser {
	/** The lexer used for this parser. */
	private Lexer lexer;
	/**
	 * The generated {@code IConditionalExpression} that is represented by the
	 * given string.
	 */
	private CompositeExpression expressions;

	/**
	 * Creates a new parser for the given query and starts the parsing process.
	 * 
	 * @param lineData
	 *            {@code String} containing the data from the query.
	 */
	public Parser(String lineData) {
		super();
		lexer = new Lexer(lineData);
		expressions = new CompositeExpression();

		nextExpression();
	}

	/**
	 * Returns the {@code IConditionalExpression} that was generated by the
	 * parser.
	 * 
	 * @return the {@code IConditionalExpression} that was generated by the
	 *         parser.
	 */
	public IConditionalExpression getExpression() {
		return expressions;
	}

	/**
	 * Calculates the next {@code IConditionalExpression} from the input
	 * {@code String}. If a new expression exists, it is added to the
	 * {@link Parser#expressions}. If there are no more expressions left,
	 * nothing happens.
	 */
	private void nextExpression() {
		if (lexer.nextToken().getType() == TokenType.EOF) {
			return;
		}

		Token token = lexer.getToken();
		IFieldValueGetter field = getField(token);
		IComparisonOperator operator = getOperator(lexer.nextToken());

		if (lexer.nextToken().getType() != TokenType.SYMBOL) {
			throw new LexerException("Invalid token type!");
		}

		lexer.setState(LexerState.STRING);
		String literal = getLiteral(lexer.nextToken());

		if (lexer.nextToken().getType() != TokenType.SYMBOL) {
			throw new LexerException("Invalid token type!");
		}
		lexer.setState(LexerState.NORMAL);

		IConditionalExpression expression = new ConditionalExpression(field, literal,
			operator);
		expressions.addExpression(expression);

		token = lexer.nextToken();
		if (token.getType() != TokenType.EOF) {
			if (token.getType() != TokenType.COMMAND
					|| !token.getValue().toString().toUpperCase().equals("AND")) {
				throw new LexerException("Invalid token type!");
			}
		}
		nextExpression();
	}

	/**
	 * Returns the appropriate {@code String} literal for the given token.
	 * 
	 * @param token
	 *            the current token.
	 * @return the generated {@code String} literal.
	 */
	private String getLiteral(Token token) {
		if (token.getType() != TokenType.STRING_LITERAL) {
			throw new LexerException("Invalid token type!");
		}

		return (String) token.getValue();
	}

	/**
	 * Returns the appropriate {@code IComparisonOperator} for the given token.
	 * 
	 * @param token
	 *            the current token.
	 * @return the generated {@code IComparisonOperator}.
	 */
	private IComparisonOperator getOperator(Token token) {
		if (token.getType() != TokenType.OPERATOR) {
			throw new LexerException("Invalid token type!");
		}

		IComparisonOperator operator;
		switch ((String) token.getValue()) {
			case "<":
				operator = new LessThanCondition();
				break;
			case "<=":
				operator = new LessOrEqualThanCondition();
				break;
			case ">":
				operator = new GreaterThanCondition();
				break;
			case ">=":
				operator = new GreaterOrEqualThanCondition();
				break;
			case "=":
				operator = new EqualsCondition();
				break;
			case "!=":
				operator = new NotEqualCondition();
				break;
			case "LIKE":
				operator = new WildCardEqualsCondition();
				break;
			default:
				throw new LexerException("Problem during parsing!");
		}
		return operator;
	}

	/**
	 * Returns the appropriate {@code IFieldValueGetter} for the given token.
	 * 
	 * @param token
	 *            the current token.
	 * @return the generated {@code IFieldValueGetter}.
	 */
	private IFieldValueGetter getField(Token token) {
		if (token.getType() != TokenType.COMMAND) {
			throw new LexerException("Invalid token type!");
		}

		IFieldValueGetter field;
		switch ((String) token.getValue()) {
			case "firstName":
				field = new FirstNameFieldGetter();
				break;
			case "lastName":
				field = new LastNameFieldGetter();
				break;
			case "jmbag":
				field = new JmbagFieldGetter();
				break;
			default:
				throw new LexerException("Problem during parsing!");
		}

		return field;
	}

}
